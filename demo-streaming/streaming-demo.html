<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="description" content="">
	<meta name="author" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<title>Potree Viewer</title>

	<link rel="stylesheet" type="text/css" href="../build/potree/potree.css">
	<link rel="stylesheet" type="text/css" href="../libs/jquery-ui/jquery-ui.min.css">
	<link rel="stylesheet" type="text/css" href="../libs/perfect-scrollbar/css/perfect-scrollbar.css">
	<link rel="stylesheet" type="text/css" href="../libs/openlayers3/ol.css">
	<link rel="stylesheet" type="text/css" href="../libs/spectrum/spectrum.css">
	<link rel="stylesheet" type="text/css" href="../libs/jstree/themes/mixed/style.css">
	<link rel="stylesheet" type="text/css" href="../common/playbar.css">
	<link rel="stylesheet" type="text/css" href="../common/overlay.css">
	<link rel="stylesheet" type="text/css" href="../common/loading-bar.css"/>
	<link rel="stylesheet" type="text/css" href="../common/draggable-overlay.css"/>
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>

<body>
	<script src="../libs/jquery/jquery-3.1.1.min.js"></script>
	<script src="../libs/spectrum/spectrum.js"></script>
	<script src="../libs/perfect-scrollbar/js/perfect-scrollbar.jquery.js"></script>
	<script src="../libs/jquery-ui/jquery-ui.min.js"></script>
	<script src="../libs/three.js/build/three.js"></script>
	<script src="../libs/other/BinaryHeap.js"></script>
	<script src="../libs/tween/tween.min.js"></script>
	<script src="../libs/d3/d3.js"></script>
	<script src="../libs/proj4/proj4.js"></script>
	<script src="../libs/openlayers3/ol.js"></script>
	<script src="../libs/i18next/i18next.js"></script>
	<script src="../libs/jstree/jstree.js"></script>
	<script src="../build/potree/potree.js"></script>
	<script src="../libs/plasio/js/laslaz.js"></script>

	<!-- <script src="../libs/three.js/examples/js/loaders/PCDLoader.js"></script> -->
	<script src="streamer.js"></script>
	<script src="rtkloader.js"></script>
	<script src="radarloader.js"></script>
	<script src="../common/playbar.js"></script>
	<script src="../libs/other/OBJLoader.js"></script>
	<script type="text/javascript" src="../common/loading-bar.js"></script>
	<script src="../common/overlay.js"></script>
	<script src="../common/draggable-overlay.js"></script>

	<!-- INCLUDE ADDITIONAL DEPENDENCIES HERE -->
	<!-- INCLUDE SETTINGS HERE -->

	<div class="potree_container" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; ">
		<div id="potree_render_area"></div>
		<div id="potree_sidebar_container"> </div>
	</div>

	<script type="x-shader/x-vertex" id="vertexshader-pointcloud">

      attribute float alpha;
      attribute float gpsTime;
			attribute vec3 originalRtkPosition;
			attribute vec3 originalRtkOrientation;

      uniform float minGpsTime;
      uniform float maxGpsTime;
			uniform float size;

			uniform vec3 currentRtkPosition;
			uniform vec3 currentRtkOrientation;

      varying float vAlpha;

			mat4 getSE3() {
				// Construct Rotation Matrix (roll pitch yaw):
				vec3 dTheta = currentRtkOrientation - originalRtkOrientation; // TODO USE BETTER INTERPOLATION
				vec3 dX = currentRtkPosition - originalRtkPosition;
				dTheta *= -1.0; // TODO why do I need to transform from current to original?
				dX *= -1.0; // TODO why do I need to translate from current to original?

				float sinRoll = sin(dTheta.x);
				float cosRoll = cos(dTheta.x);
				float sinPitch = sin(dTheta.y);
				float cosPitch = cos(dTheta.y);
				float sinYaw = sin(dTheta.z);
				float cosYaw = cos(dTheta.z);

				mat3 Rx = mat3(
					1.0, 	0.0, 			0.0,
					0.0,	cosRoll,	sinRoll,
					0.0,	-sinRoll, cosRoll
				);

				mat3 Ry = mat3(
					cosPitch,	0.0, 	-sinPitch,
					0.0,			1.0,	0.0,
					sinPitch, 0.0,	cosPitch
				);

				mat3 Rz = mat3(
					cosYaw, 	sinYaw, 0.0,
					-sinYaw, 	cosYaw, 0.0,
					0.0,			0.0,		1.0
				);

				mat3 R = Rz*Ry*Rx;		// Rotation Matrix from Euler angles using XYZ convention
				vec4 T = vec4(dX, 1.0); // Translation Vector in Homogenous Coordinates

				mat4 SE3 = mat4(R); // creates a 4x4 matrix with 1 on the diagonal and zeros on the rest of the new additions
				SE3[3] = T; // Set the translation vector components

				return SE3;
			}

      void main() {
        if (minGpsTime <= gpsTime && gpsTime <= maxGpsTime) {
          vAlpha = 1.0;
        } else {
          vAlpha = 0.0;
        }


				mat4 SE3 = getSE3();

				// Apply SE3 transformation to the current position;
				vec3 tmp = position - vec3(200.0, 200.0, 100.0);
				vec4 newPosition = SE3*vec4(tmp, 1.0);


				vec4 mvPosition = modelViewMatrix * newPosition;
				// vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
				gl_Position = projectionMatrix * mvPosition;
				gl_PointSize = size;

				// vAlpha = 1.0;
      }
  </script>

	<script type="x-shader/x-vertex" id="vertexshader-radar">

			attribute float alpha;
			attribute float gpsTime;
			attribute vec3 originalRtkPosition;
			attribute vec3 originalRtkOrientation;

			uniform float minGpsTime;
			uniform float maxGpsTime;
			uniform float size;

			varying float vAlpha;

			void main() {
				if (minGpsTime <= gpsTime && gpsTime <= maxGpsTime) {
					vAlpha = 1.0;
				} else {
					vAlpha = 0.0;
				}

			vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
			gl_Position = projectionMatrix * mvPosition;
			gl_PointSize = size;
			}
	</script>


  <script type="x-shader/x-fragment" id="fragmentshader">
      uniform vec3 color;
      varying float vAlpha;

      void main() {
          gl_FragColor = vec4( color, vAlpha );
      }
  </script>


  <script>
    // Initialize Viewer:
    window.viewer = new Potree.Viewer(document.getElementById("potree_render_area"));

    viewer.setEDLEnabled(true);
    viewer.setFOV(60);
    viewer.setPointBudget(1*1000*1000);
    viewer.loadSettingsFromURL();

    viewer.setDescription("Example page to test out streaming point clouds into Potree using Three.js");

    viewer.loadGUI(() => {
      viewer.setLanguage('en');
			// viewer.setBackground('white');
      $("#menu_tools").next().show();
      $("#menu_scene").next().show();
      // viewer.toggleSidebar();
			$(("#show_bounding_box")).trigger("click");
    });

		// Initializations:
		var viewerOffset = 100;
		var bboxMax;
		var geoms = [];
		var mesh5M, mesh18M;
		var waitOnCapacity = 2;
		var waitOn = waitOnCapacity;

		// Performance Timing:
		var t0 = performance.now();
		var t1 = 0;

		var rtkOffset, rtkRange, rtkLookup, rtkPosInit, rtkOrientInit, radarOffset, radarRange, lidarOffset, lidarRange;
		window.animationPaused = true; // move this somewhere better
	  var camPoint = new THREE.Vector3(7.011, -5.318, 8.326);
	  viewer.scene.view.position.copy(camPoint); // changed from camera

		setLoadingScreen();
		window.lastPauseTime = 0;

  </script>

  <script>


	 ////////////////////////////////////////////////////////////////////////////
	 ////////////////////////////////////////////////////////////////////////////
	 ////////////////////////////////////////////////////////////////////////////

	 // Load Initial Point Cloud:
	 console.log("Starting Client Streaming Application");

	 // Create Settings:
	 var settings = {
	 	serverUrl: "http://localhost",
		// serverUrl: "http://172.18.44.138",	// virtual box
		// serverUrl: "http://18.208.171.218",	// ec2 Server
	 	port: "4321",
	 	// headerFilename: "test.lidar.bin.header",
	 	// filename: "test.lidar.bin",
	 	headerFilename: "full_pointcloud-large-zeroed-int16.csv.bin.header",
	 	filename: "full_pointcloud-large-zeroed-int16.csv.bin",
		rtkFile: "rtk.csv",
		isOdcData: true,
	 	maxMemMB: 10,	// TODO try 40 bytes
		bufferEpsilonSec: 6,
	 	TA: 10	// Seconds
	 }

	 // TODO define this in a better way:
	 var speedFactor = 9;
	 // var speedFactor = 33;

	 var heartbeat;
	 var slice;
	 var header;

 	// Create Geometry and Mesh:
	var cloudGeometry = new THREE.BufferGeometry();
	var material = new THREE.ShaderMaterial({
		size: 0.05, // 0.005
		// vertexColors: THREE.VertexColors,	// NOTE using THREE.VertexColors allows individual points to have their own color
		vertexShader:   document.getElementById( 'vertexshader-pointcloud' ).textContent,
		fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
		transparent:    true,
		opacity: 0.0,
		depthWrite: 		 false,		// Otherwise, points behind transparent points will be hidden
		uniforms: {
			size: {value: 0.05},
			color: { value: new THREE.Color( 0x003DFF ) },
			minGpsTime: {value: 0.0 },
			maxGpsTime: {value: 0.0 },
			currentRtkPosition: {type: "v3", value: new THREE.Vector3(0,0,0)},
			currentRtkOrientation: {type: "v3", value: new THREE.Vector3(0,0,0)},
			// velo2RtkXYZ: {type: "v3", value: new THREE.Vector3(0,0,0)},
			// velo2RtkXYZ: {type: "v3", value: new THREE.Vector3(0,0,0)},
			// rtk2VehicleXYZ: {type: "v3", value: new THREE.Vector3(0,0,0)},
			// rtk2VehicleRPY: {type: "v3", value: new THREE.Vector3(0,0,0)}
			// initialTime: {value: t_init}
		}
	});
	var cloudMesh = new THREE.Points(cloudGeometry, material);
	cloudMesh.timeRange = {tmin: 0, tmax: 0};
	cloudMesh.name = "cloud";
	viewer.scene.scene.add(cloudMesh);

	// Send Header Request:
	sendHeaderRequest(settings.serverUrl + ":" + settings.port + "/args/header/" + settings.headerFilename, (e) => {
		console.log(e);

		// Launch Data Loader to Start Streaming:
		header = e.data;
		streamFromFileStart(header, settings);

		// TODO LOAD velo2rtk INSTEAD OF DEFINING HERE:
		var velo2rtk = {
			x: 0,
			y: 0,
			z: 0,
			roll: 0,
			pitch: 0,
			yaw: 0
		}
		// debugger; // follow step
		storeVelo2Rtk(velo2rtk);

		Potree.loadPointCloud("../pointclouds/placeholders/cube-cloud/cloud.js", "cloud", function(e){ // TODO use empty, but remove GPS_TIME attribute from cloud.js
			viewer.scene.addPointCloud(e.pointcloud);
			e.pointcloud.position.z = 0;
			let material = e.pointcloud.material;
			material.size = 1;
			material.pointSizeType = Potree.PointSizeType.FIXED;
			material.shape = Potree.PointShape.SQUARE
			// material.pointColorType = Potree.PointColorType.INTENSITY;
			material.pointColorType = Potree.PointColorType.ELEVATION;
			// material.pointColorType = Potree.PointColorType.POINT_INDEX;

			// debugger; // material uniforms
			material.uniforms.currentRtkPosition = {type: "v3", value: new THREE.Vector3(0,0,0)};
			material.uniforms.currentRtkOrientation = {type: "v3", value: new THREE.Vector3(0,0,0)};

			// Update material with calibration
			let velo2rtk = getVelo2Rtk();
			let rtk2vehicle = getRtk2Vehicle();
			material.uniforms.velo2RtkXYZ = {type: "v3", value: new THREE.Vector3(velo2rtk.x, velo2rtk.y, velo2rtk.z)};
			material.uniforms.velo2RtkRPY = {type: "v3", value: new THREE.Vector3(velo2rtk.roll, velo2rtk.pitch, velo2rtk.yaw)};
			material.uniforms.rtk2VehicleXYZ = {type: "v3", value: new THREE.Vector3(rtk2vehicle.x, rtk2vehicle.y, rtk2vehicle.z)};
			material.uniforms.rtk2VehicleRPY = {type: "v3", value: new THREE.Vector3(rtk2vehicle.roll, rtk2vehicle.pitch, rtk2vehicle.yaw)};

			// Function to update these values as calibration extrinsics get updated
			window.addEventListener("update-calibration-panel", (e) => {
				console.log("calibration panel updated: ", e.detail);
				id = e.detail.id;
				dim = e.detail.dim;
				val = e.detail.value;

				if (id == "rtk2vehicle") {
					let rtk2vehicle = getRtk2Vehicle();
					material.uniforms.rtk2VehicleXYZ = {type: "v3", value: new THREE.Vector3(rtk2vehicle.x, rtk2vehicle.y, rtk2vehicle.z)};
					material.uniforms.rtk2VehicleRPY = {type: "v3", value: new THREE.Vector3(rtk2vehicle.roll, rtk2vehicle.pitch, rtk2vehicle.yaw)};
				} else if (id == "velo2rtk") {
					let velo2rtk = getVelo2Rtk();
					material.uniforms.velo2RtkXYZ = {type: "v3", value: new THREE.Vector3(velo2rtk.x, velo2rtk.y, velo2rtk.z)};
					material.uniforms.velo2RtkRPY = {type: "v3", value: new THREE.Vector3(velo2rtk.roll, velo2rtk.pitch, velo2rtk.yaw)};
				} else {
					console.error("Unknown Calibration Extrinsics Id:", id);
				}
			});

		});



	});




	 // sendHeaderRequest(serverUrl + ":" + port + "/args/header/cloud-18M-header.pcd", (e) => {
		//  var streamingHeader = e.data;
		//  console.log("Header File Received: ", streamingHeader);
	 //
		//  // Stream from time 0:
		//  streamFromTime(0, streamingHeader, streamSettings, (attributes) => {
	 //
		// 	//  // Create Geometry:
		// 	cloudGeometry.addAttribute('position', new THREE.Float32BufferAttribute( attributes.pos, 3 ));
		// 	cloudGeometry.addAttribute('gpsTime', new THREE.Float32BufferAttribute( attributes.timestamp, 1 ));
		// 	cloudGeometry.computeBoundingSphere();
		// 	// debugger; // cloudGeometry
	 //
	 //
		// 	 mesh.timeRange = {tmin: attributes.timestamp[0], tmax: attributes.timestamp[attributes.timestamp.length-1]};
		// 	 debugger; // mesh.timeRange
	 //
	 //
		// 	 // Set initial camera position:
		// 	 camPos = [attributes.pos[0]+viewerOffset, attributes.pos[1]+viewerOffset, attributes.pos[2]+viewerOffset];
	 //
		// 	 viewer.scene.view.position.set(...camPos);
		// 	 viewer.scene.view.lookAt(cloudGeometry.boundingSphere.center);
		//  });
	 //
	 // });

 	 ////////////////////////////////////////////////////////////////////////////
 	 ////////////////////////////////////////////////////////////////////////////
 	 ////////////////////////////////////////////////////////////////////////////

	// Load Radar:
	 loadRadar("radarData.csv", true, (geometry, t_init) => {
		 // uniforms
		 uniforms = {
			   size: {value: 5.0},
				 color: { value: new THREE.Color( 0xffff00 ) },
				 minGpsTime: {value: 0.0 },
				 maxGpsTime: {value: 0.0 },
				 initialTime: {value: t_init}
		 };
		 // // point cloud material
		 var shaderMaterial = new THREE.ShaderMaterial( {
				 uniforms:       uniforms,
				 vertexShader:   document.getElementById( 'vertexshader-radar' ).textContent,
				 fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
				 transparent:    true,
				 depthTest: 		 false		// Will not be hidden behind anything
		 });
		 var material = new THREE.PointsMaterial( {size:0.01} );
		 material.uniforms = uniforms;
		 // material.uniforms.size = uniforms.size;
		 // material.uniforms.color = uniforms.color;
		 // material.uniforms.minGpsTime = uniforms.minGpsTime;
		 // material.uniforms.maxGpsTime = uniforms.maxGpsTime;
		 // material.uniforms.initialTime = uniforms.initialTime;

		 // TODO RADAR TO RTK TO VEHICLE EXTRINSICS (IF NEEDED):

		 var mesh = new THREE.Points(geometry, shaderMaterial); // TODO using regular material in the meantime b/c of shader changes for pointcloud
		 mesh.name = "radar";
		 viewer.scene.scene.add(mesh);
	 });

	 // Load RTK:
	 let rtkFile = settings.serverUrl + ":" + settings.port + "/" + settings.rtkFile;
	 console.log("rtkFile: ", rtkFile);
	 loadRtk(rtkFile, settings.isOdcData, (pos, rot, t_init, t_range, numPoints, distance, rtkLookupOutput, pos_init, orient_init, rtk2vehicle) => {
		 rtkOffset = t_init;
		 rtkRange = t_range;
		 rtkLookup = rtkLookupOutput;
		 rtkPosInit = new THREE.Vector3(pos_init[0], pos_init[1], pos_init[2]);
		 rtkPosInit.z -= 2.0; // TODO hack for vehicle to rtk transform
		 // TODO RTK TO VEHICLE (Maybe do this in RTK LOADER)
		 storeRtk2Vehicle(rtk2vehicle);



		 rtkOrientInit = new THREE.Vector3(orient_init[0], orient_init[1], orient_init[2]);

		 DataLoader.postMessage({msg:"rtkTimeConversion", rtkTimeConversion:{rtkOffset: rtkOffset, rtkRange:rtkRange}});
		 DataLoader.postMessage({msg:"rtkLookup", rtkLookup: rtkLookupOutput});

		 console.log("RTK Trajectory Length: ", distance, "meters");
		 path = pos.map(v => new THREE.Vector3(...v));
		 orientations = rot.map(v => new THREE.Vector3(...v));
		 let animationPath = new Potree.AnimationPath(path);
		 animationPath.closed = false;
		 var orientationPath = new THREE.CatmullRomCurve3(orientations, animationPath.closed); // NOTE: orientations are represented as a parametric curve in 3d space, this breaks at pi to negative pi transition

		 { // render the path
			 let geometry = animationPath.getGeometry();
			 let material = new THREE.LineBasicMaterial();
			 material.uniforms = {
				 initialTime:{value:t_init},
				 timeRange: {value:t_range},
				 numPoints: {value: numPoints}
			 };
			 let line = new THREE.Line(geometry, material, {closed: animationPath.closed});
			 line.name = "rtk";
			 line.visible = false;
			 viewer.scene.scene.add(line);
			 console.log("Rendered Path");
		 }

		 // CREATE VEHICLE OBJECT:
		 // NOTE for Mustang: {texture: models/bodybkgd.JPG, mesh: models/1967-shelby-ford-mustang.obj}
		 // NOTE for Volt: {texture: models/Chevy_Volt_Segmented/Chevrolet_Volt_v1_exterior.png, mesh: resources/models/Chevy_Volt_Segmented/Chevy_Volt_2016.obj}
		 let manager = new THREE.LoadingManager();
		 manager.onProgress = function ( item, loaded, total ) {
			 console.log( item, loaded, total );
		 };
		 let textureLoader = new THREE.TextureLoader( manager );
		 let texture = textureLoader.load(`${Potree.resourcePath}/models/Chevy_Volt_Segmented/reflection_1.png`);

		 let onProgress = function ( xhr ) {
			 if ( xhr.lengthComputable ) {
				 let percentComplete = xhr.loaded / xhr.total * 100;
				 console.log( Math.round(percentComplete, 2) + '% downloaded' );
			 }
		 };
		 texture.wrapS = THREE.RepeatWrapping;
		 texture.wrapT = THREE.RepeatWrapping;

		 { // Load Textured bunny from obj
			 let onError = function ( xhr ) {};
			 let loader = new THREE.OBJLoader( manager );
			 loader.load(`${Potree.resourcePath}/models/Chevy_Volt_Segmented/Chevy_Volt_2016.obj`, function ( object ) {
			 // loader.load(`${Potree.resourcePath}/models/1967-shelby-ford-mustang.obj`, function ( object ) {
				 object.traverse( function ( child ) {
					 if ( child instanceof THREE.Mesh ) {
						 child.material.map = texture;
					 }
				 } );
				 object.name = "bunny";
				 object.position.set(...pos[0]);
				 object.scale.multiplyScalar(.011);
				 object.orientationPath = orientationPath;
				 object.rotation.set(0*Math.PI / 2, 0*Math.PI/2., 1*Math.PI/2.0); // Chevy Volt
				 object.initialRotation = object.rotation.clone(); // NOTE is this used?
				 // object.rotation.set(Math.PI / 2, 0*Math.PI/2., 0*Math.PI/2.0); // Shelby Mustang
				 viewer.scene.scene.add( object );
				 // debugger; // pos[0
				 var camPos = pos[0];
				 // viewer.scene.view.position.set(camPos[0]+viewerOffset, camPos[1]+viewerOffset, camPos[2]+viewerOffset);
				 // viewer.scene.view.lookAt(new THREE.Vector3(...pos[0]));
			 }, onProgress, onError );
		 }


		 // ANIMATION:
		 { // create Animation Path & make light follow it
			 {// ANIMATION + SLIDER LOGIC:
				 let slider = document.getElementById("myRange");
				 let output = document.getElementById("demo");
				 let tmin = document.getElementById("playbar_tmin");
				 let tmax = document.getElementById("playbar_tmax");
				 let toggleplay = document.getElementById("toggleplay");
				 let playbackSpeed = document.getElementById("playback_speed");
				 output.innerHTML = slider.value;

				 // Animate from beginning to end
				 var start = 0;
				 var end = Infinity;
				 var speed = playbackSpeed.value*0.25*speedFactor;	// empirically set as "close to realtime"
				 var animation = animationPath.animate(start, end, speed, animate);

				 function animate(t, updateCamera=true) {
					 animation.repeat = true;

					 // TODO cache this to improve speed?
					 // lidarOffset = 1495189467.550001;  // TODO Hardcoded b/c PotreeConverter is throwing away initial offset
					 rtkMesh = viewer.scene.scene.getObjectByName("rtk");
					 radarMesh = viewer.scene.scene.getObjectByName("radar");
					 rtkOffset = rtkMesh.material.uniforms.initialTime.value;
					 radarOffset = radarMesh.material.uniforms.initialTime.value;
					 numRtkPoints = rtkMesh.material.uniforms.numPoints.value;
					 numRadarPoints = radarMesh.geometry.attributes.gpsTime.count;

					 // timeMin = Math.min(lidarOffset, rtkOffset, radarOffset);
					 timeMin = Math.min(rtkOffset, radarOffset);
					 // lidarRange = viewer.scene.pointclouds[0].pcoGeometry.nodes.r.gpsTime.range;
					 // radarRange = 583.649169921875;  // TODO Hardcoded
					 radarRange = radarMesh.geometry.attributes.gpsTime.array[numRadarPoints-1];
					 // rtkRange = 600.5599999427795;   // TODO Hardcoded
					 rtkRange = rtkMesh.material.uniforms.timeRange.value;

					 // timeMax = Math.max((lidarRange+lidarOffset), (radarRange+radarOffset), (rtkRange+rtkOffset));
					 timeMax = Math.max((radarRange+radarOffset), (rtkRange+rtkOffset));
					 timeOffset = timeMin;
					 timeRange = timeMax - timeMin;
					 // console.log("Radar Initial Time: ", radarOffset);
					 // console.log("RTK Initial Time: ", rtkOffset);
					 // debugger;
					 // t is a value between 0 and 1 in rtkTime frame
					 var gpsTime = (rtkRange*t) + rtkOffset;  // Convert from rtkTime to gpsTime


					 // TODO define slider time frame
					 slider.value = 100*t; // NOTE this is currently only using the rtkTime as the time frame
					 output.innerHTML = (gpsTime-rtkOffset).toFixed(4); // Centered to zero
					 window.dispatchEvent(new Event("time-updated"));
					 // use getPoint(t) to map from t to the position on the animation path


					 var bunny = viewer.scene.scene.getObjectByName("bunny");
					 let rtkPoint = animation.getPoint(t); // NOTE t is in rtkTime
					 let vehicleOrientation = bunny.orientationPath.getPoint(t);
					 rtkPoint.z -= 2.0;
					 bunny.position.copy(rtkPoint);
					 applyRotation(bunny, vehicleOrientation.x, vehicleOrientation.y, vehicleOrientation.z);
					 bunny.visible = true;

					 // Create GPS Time Clipping Event:
					 var minGpsTime = gpsTime + parseFloat(tmin.value);
					 var maxGpsTime = gpsTime + parseFloat(tmax.value);
					 // debugger; // maxGpsTime

					 // Get Current RTK Pose:
					 var currentRtkPosition = rtkPoint.sub(rtkPosInit);
					 var currentRtkOrientation = vehicleOrientation.sub(rtkOrientInit);

					 // // Animate Point Cloud:
					 minLidarTime = minGpsTime - header.tmin;
					 maxLidarTime = maxGpsTime - header.tmin;
					 viewer.setFilterGPSTimeRange(minLidarTime, maxLidarTime);
					 viewer.setFilterGPSTimeExtent(minLidarTime-10, maxLidarTime+10);
					 // debugger; // uniforms below
					 var pcloud = viewer.scene.pointclouds[0];
					 pcloud.material.uniforms.currentRtkPosition.value.copy(currentRtkPosition);
					 pcloud.material.uniforms.currentRtkOrientation.value.copy(currentRtkOrientation);

					 var cloud = viewer.scene.scene.getObjectByName("cloud");
					 cloud.material.uniforms.minGpsTime.value = minLidarTime;
					 cloud.material.uniforms.maxGpsTime.value = maxLidarTime;
					 cloud.material.uniforms.currentRtkPosition.value.copy(currentRtkPosition);
					 cloud.material.uniforms.currentRtkOrientation.value.copy(currentRtkOrientation);

					 // Animate Radar:
					 minRadarTime = minGpsTime - radarOffset;
					 maxRadarTime = maxGpsTime - radarOffset;
					 var radar = viewer.scene.scene.getObjectByName("radar");
					 radar.material.uniforms.minGpsTime.value = minRadarTime;
					 radar.material.uniforms.maxGpsTime.value = maxRadarTime;
					 // console.log(radar);
					 // debugger; // check the rtkTime, slider time, radar time, lidar time

					 if (updateCamera) {
						 let camera = viewer.scene.getActiveCamera();
						 let lag = 1.01; // seconds
						 lagTime = Math.max(0, (gpsTime - lag - rtkOffset)/rtkRange);
						 // let lagTime = Math.max(0, (gpsTime-lag)/viewer.scene.pointclouds[0].pcoGeometry.nodes.r.gpsTime.range);
						 let camPoint = animation.getPoint(lagTime);  // Get point with 2 second lag
						 camPoint.z += 10;

						 // TODO messing around:
						 camPoint = new THREE.Vector3(3.356, -11.906, 3.126);
						 // viewer.scene.view.position.copy(camPoint); // changed from camera
						 var targetPosition = new THREE.Vector3(0, 0, 0);
						 // viewer.scene.view.lookAt(targetPosition);
						 bunny.position.copy(targetPosition);
						 bunny.position.z -= 2;

						 // viewer.scene.view.position.copy(camPoint); // changed from camera
						 // var targetPosition = new THREE.Vector3(bunny.position.x, bunny.position.y, bunny.position.z+2);
					 }
				 }
				 window.animation = animation;

				 // Playbar Button Functions:
				 let playbutton = document.getElementById("playbutton");
				 let pausebutton = document.getElementById("pausebutton");
				 pausebutton.addEventListener("mousedown", () => {
					 animation.pause();
				 });
				 playbutton.addEventListener("mousedown", () => {
					 animation.resume();
				 });
				 slider.addEventListener("wheel", () => {
					 animation.pause();
					 var val = slider.value/100.0;
					 animation.t = val;
					 animate(val, updateCamera=false);
				 });
				 window.addEventListener("keypress", (e) => {
					 if (e.charCode == 32) {
							 if (toggleplay.checked) {
								 animation.resume();
							 } else {
								 animation.pause();
							 }
						 }
					 });
					 slider.addEventListener("input", () => {
					 	animation.pause();
					 	$("playbar_toggle").click();
					 	var val = slider.value/100.0;
					 	animation.t = val;
					 	animate(val);
					 });

					 slider.addEventListener("mouseup", (e) => {
						 console.log("mouseup event: ", e);

						 streamFromTimeNew(slider.value/100, {offset:rtkOffset, range: rtkRange}, header, settings);
						 setLoadingScreen();
						 window.firstSliceRequested = true;

					 });

					 playbackSpeed.addEventListener("mouseup", (e) => {
						 let speed = playbackSpeed.value*0.25 * speedFactor;
						 playbackSpeed.setAttribute("title", speed);
						 animation.speed = speed;
						 animation.pause();
						 animation.resume();
						 console.log("set speed to: ", speed);
					 })

					 window.addEventListener("time-updated", () => {

						 if (typeof(window.numTimeUpdated) == "undefined") {
							 window.numTimeUpdated = 0;
						 } else {
							 window.numTimeUpdated++;
						 }

						 var lidarTime = 0;
						 var window_tmin = -0.05; // note the negative
						 var window_tmax = 0.05;
			       if (rtkRange != null && rtkOffset != null && header.tmin != null) {
			         lidarTime = $("#myRange").val()/100*rtkRange + rtkOffset - header.tmin
			       }

						 // Get Time Window Boundaries:
						 window_tmin = parseFloat($("#playbar_tmin").val());
						 window_tmax = parseFloat($("#playbar_tmax").val());

						 // Get Current Slice Time Frame (TA):
						 try {
							 var numPoints = cloudMesh.geometry.attributes.gpsTime.length;
							 TAmin = cloudMesh.geometry.attributes.gpsTime.array[0];
							 TAmax = cloudMesh.geometry.attributes.gpsTime.array[numPoints-1];


							 // Request Slice Logic:
							 var epsilon = 0.05;		// TODO ensure this value is valid and move somewhere better (or ideally empirically determine this based on network/hardware settings)
							 var sliceTimeSec = window.sliceTimeMillis/1000;		// TODO measure this after first slice

							 // Slice Boundaries:
							 var slicemin = lidarTime - window_tmin - epsilon;
							 var slicemax = slicemin + settings.TA;

							 // DataLoader Buffers:
							 TBmin = heartbeat.tmin;
							 TBmax = heartbeat.tmax;

							 console.assert((window_tmax - window_tmin + sliceTimeSec) < settings.TA);

							 // Request Slice:
							 if ((lidarTime + window_tmax + sliceTimeSec + epsilon) > TAmax) {
								 requestSlice(slicemin, slicemax);
							 }

							 // TODO potentially need to remove this after testing:
							 // Pause animation if window_tmax + lidarTime > TA:
							 if ((lidarTime + window_tmax + epsilon) > TAmax) {
								 // debugger; // check why breaking here
								 console.log("VINAY",window.animation);
								 window.animation.pause(); 	// This isn't pausing
								 // $("#pausebutton").mousedown();
								 setLoadingScreen();
								 window.animationPaused = true;

								 // Slow down animation speed:
							 }




						 } catch (e) {
							 console.error("Error at Player Slicing Logic: ", e);
						 }




						 // var updateRestriction = 100000; // only update once every updates
						 // if ((window.numTimeUpdated % updateRestriction) == 0) {
						 //
							//  if (typeof(viewer.scene.scene.getObjectByName("rtk")) != "undefined") {
						 //
							//   sliderVal = slider.value/100.0;
							//   var time = sliderVal * rtkRange + rtkOffset - header.tmin;
						 //
							//   var swap = {
							//  	 tmin: Math.max(0, time),	// start of file check
							//  	 tmax: Math.min(time+settings.TA, header.tmax-header.tmin) // end of file check
							//   }
							//   swap.t = swap.tmin/(header.tmax-header.tmin);
						 //
						 //
							//   if (swap.tmax > heartbeat.tmax) {
							//  	 if (swap.tmin > heartbeat.tmax) {
							//  		 // DataLoader.postMessage({msg: "terminate"});	// TODO no longer terminate
							//  		 // streamFromTime(swap.t, header, settings);		// NOTE disabled streamFromTime
							//  	 } else {
							//  		 // wait -- aka do nothing?
							//  	 }
							//   } else if (swap.tmin < heartbeat.tmin) {
							//  	 // DataLoader.postMessage({msg: "terminate"}); 	// TODO no longer terminate
							//  	 // streamFromTime(swap.t, header, settings);		// NOTE disabled streamFromTime
							//   } else {
							//  	 // Send Slice Request:
							//  	 DataLoader.postMessage({
							//  		 msg: "slice",
							//  		 tmin: swap.tmin,
							//  		 tmax: swap.tmax
							//  	 });
							//   }
							//  }
						 // }


					 });
				 $("#pausebutton").trigger("mousedown");
			 }
			 window.animationPath = animationPath;
			 window.animation.pause();
		 }
	 });

  </script>

	<script>

		function storeRtk2Vehicle(rtk2vehicle) {
			try {
				$("#rtk2vehicle-setpoint-x").val(rtk2vehicle.x);
				$("#rtk2vehicle-x").text(rtk2vehicle.x.toFixed(4));
				$("#rtk2vehicle-setpoint-y").val(rtk2vehicle.y);
				$("#rtk2vehicle-y").text(rtk2vehicle.y.toFixed(4));
				$("#rtk2vehicle-setpoint-z").val(rtk2vehicle.z);
				$("#rtk2vehicle-z").text(rtk2vehicle.z.toFixed(4));
				$("#rtk2vehicle-setpoint-roll").val(rtk2vehicle.roll);
				$("#rtk2vehicle-roll").text(rtk2vehicle.roll.toFixed(4));
				$("#rtk2vehicle-setpoint-pitch").val(rtk2vehicle.pitch);
				$("#rtk2vehicle-pitch").text(rtk2vehicle.pitch.toFixed(4));
				$("#rtk2vehicle-setpoint-yaw").val(rtk2vehicle.yaw);
				$("#rtk2vehicle-yaw").text(rtk2vehicle.yaw.toFixed(4));
				console.log("Stored Rtk to Vehicle Extrinsics");

			} catch (e) {
				console.error("Could not store RTK to Vehicle Calibration Extrinsics", e);
			}
		}

		function storeVelo2Rtk(velo2rtk) {
			try {
				$("#velo2rtk-setpoint-x").val(velo2rtk.x);
				$("#velo2rtk-x").text(velo2rtk.x.toFixed(4));
				$("#velo2rtk-setpoint-y").val(velo2rtk.y);
				$("#velo2rtk-y").text(velo2rtk.y.toFixed(4));
				$("#velo2rtk-setpoint-z").val(velo2rtk.z);
				$("#velo2rtk-z").text(velo2rtk.z.toFixed(4));
				$("#velo2rtk-setpoint-roll").val(velo2rtk.roll);
				$("#velo2rtk-roll").text(velo2rtk.roll.toFixed(4));
				$("#velo2rtk-setpoint-pitch").val(velo2rtk.pitch);
				$("#velo2rtk-pitch").text(velo2rtk.pitch.toFixed(4));
				$("#velo2rtk-setpoint-yaw").val(velo2rtk.yaw);
				$("#velo2rtk-yaw").text(velo2rtk.yaw.toFixed(4));
				console.log("Stored Rtk to Vehicle Extrinsics");

			} catch (e) {
				console.error("Could not store Velodyne to RTK Calibration Extrinsics", e);
			}
		}



	</script>


</body>
</html>
