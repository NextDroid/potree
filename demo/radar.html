<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="description" content="">
	<meta name="author" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<title>Potree Viewer</title>

	<link rel="stylesheet" type="text/css" href="../build/potree/potree.css">
	<link rel="stylesheet" type="text/css" href="../libs/jquery-ui/jquery-ui.min.css">
	<link rel="stylesheet" type="text/css" href="../libs/perfect-scrollbar/css/perfect-scrollbar.css">
	<link rel="stylesheet" type="text/css" href="../libs/openlayers3/ol.css">
	<link rel="stylesheet" type="text/css" href="../libs/spectrum/spectrum.css">
	<link rel="stylesheet" type="text/css" href="../libs/jstree/themes/mixed/style.css">
	<link rel="stylesheet" href="../common/overlay.css" type="text/css">
	<link rel="stylesheet" href="../common/loading-bar.css" type="text/css">
  <!-- <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet"> -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
	<script src="../node_modules/flatbuffers/js/flatbuffers.js"></script>
	<!-- <script type="module" src="../readers/polyline3D.js"></script>
	<script type="module" src="../schemas/GroundTruth_generated_tmp.js"></script> -->
  <script type="module" src="radarLoader.js"></script>
  <script type="module" src="rtkLoader.js"></script>
  <script type="module" src="laneLoader.js"></script>
  <script type="module" src="trackLoader.js"></script>
  <script type="module" src="gapsLoader.js"></script>
  <link rel="stylesheet" type="text/css" href="../common/playbar.css">
</head>

<body>
	<script src="../libs/jquery/jquery-3.1.1.min.js"></script>
	<script src="../libs/spectrum/spectrum.js"></script>
	<script src="../libs/perfect-scrollbar/js/perfect-scrollbar.jquery.js"></script>
	<script src="../libs/jquery-ui/jquery-ui.min.js"></script>
	<script src="../libs/three.js/build/three.min.js"></script>
	<script src="../libs/other/BinaryHeap.js"></script>
	<script src="../libs/tween/tween.min.js"></script>
	<script src="../libs/d3/d3.js"></script>
	<script src="../libs/proj4/proj4.js"></script>
	<script src="../libs/openlayers3/ol.js"></script>
	<script src="../libs/i18next/i18next.js"></script>
	<script src="../libs/jstree/jstree.js"></script>
	<script src="../build/potree/potree.js"></script>
	<script src="../libs/plasio/js/laslaz.js"></script>
  <script src="../libs/other/OBJLoader.js"></script>
	<script src="../common/playbar.js"></script>
	<script src="../common/loading-bar.js"></script>
	<script type="module" src="../common/overlay.js"></script>
	<script src="../node_modules/three.meshline/src/THREE.MeshLine.js"></script>
	<script src="animationEngine.js"></script>


	<!-- TODO REMOVE BELOW -->
	<script src="tweenTest.js"></script>



	<!-- <script src="../common/playbar.css"></script> -->


	<!-- INCLUDE ADDITIONAL DEPENDENCIES HERE -->
  <script src="https://sdk.amazonaws.com/js/aws-sdk-2.339.0.min.js"></script>

	<!-- INCLUDE SETTINGS HERE -->

	<div class="potree_container" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; ">
	  <div id="potree_render_area"></div>
		<div id="potree_sidebar_container"></div>
	</div>


  <script type="x-shader/x-vertex" id="vertexshader">

      attribute float alpha;
      attribute float gpsTime;

      uniform float minGpsTime;
      uniform float maxGpsTime;

	  uniform vec3 offset;

      varying float vAlpha;

      void main() {

        if (minGpsTime <= gpsTime && gpsTime <= maxGpsTime) {
          vAlpha = 1.0;
        } else {
          vAlpha = 0.0;
        }


        // if (gpsTime > 30.0) {
				// 	vAlpha = 0.0;
        // } else {
        //   vAlpha = 1.0;
        // }

					// vec4 offset = vec4( 0.0, 0.0, 0.0, 0.0);
					// vec4 offset = vec4( 300016.625, 4701260, 247.1885223388672, 0.0);

          vec4 mvPosition = modelViewMatrix * vec4( position+offset.xyz, 1.0 );
					gl_Position = projectionMatrix * mvPosition;

          gl_PointSize = 8.0;


      }

  </script>

  <script type="x-shader/x-fragment" id="fragmentshader">

      uniform vec3 color;

      varying float vAlpha;

      void main() {

          gl_FragColor = vec4( color, vAlpha );

      }

  </script>





	<script type="module">
		import { loadLanes } from "../demo/laneLoader.js";
		import { loadTracks } from "../demo/trackLoader.js";
		import { loadDetections } from "../demo/detectionLoader.js";
		import { loadRtk, applyRotation } from "../demo/rtkLoader.js";
		import { loadRadar } from "../demo/radarLoader.js";
		import { loadGaps } from "../demo/gapsLoader.js";
		// import {  } from "../common/overlay.js";
		import { setLoadingScreen, removeLoadingScreen } from "../common/overlay.js";

		// setLoadingScreen();

		const runForLocalDevelopment = location.search === "" && (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1');

		const params = new URLSearchParams(location.search);
		console.log(location);
		const bucket = params.get("bucket");
		const region = params.get("region");
		const name = params.get("name");
		const accessKeyId = params.get("key1");
		const secretAccessKey = params.get("key2");
		const fonts =  JSON.parse(params.get("fonts"));
		const theme = JSON.parse(params.get("theme")); // material-ui theme

		if (fonts) {
			const head = document.head;
			fonts.forEach(font => {
				const link = document.createElement('link');
				link.rel = 'stylesheet';
				link.href = font;
				head.appendChild(link);
			});

			// Override fonts specified.
			const {typography} = theme;
			const style = document.createElement('style');
			style.innerHTML = `#value {font-family: ${typography.fontFamily} !important;} #sidebar_root {font-family: ${typography.fontFamily} !important;} #potree_languages {font-family: ${typography.fontFamily} !important;}`;
			head.appendChild(style);
		}

    const s3 = bucket && region && name && accessKeyId && secretAccessKey &&
          new AWS.S3({apiVersion: '2006-03-01',
                      region,
                      accessKeyId,
                      secretAccessKey
                     });

	 if (!(s3 || window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1')) { window.history.back() };
    // We really want this, but it doesn't work in the browser. Only on a server.
    // const stream = s3.getObject({Bucket: bucket,
    //                              Key: name}).createReadStream();
    // console.log(stream);

    window.viewer = new Potree.Viewer(document.getElementById("potree_render_area"));

		viewer.setEDLEnabled(true);
		viewer.setFOV(60);
		viewer.setPointBudget(1*1000*1000);
		document.title = "";
		viewer.setEDLEnabled(false);
		viewer.setBackground("gradient"); // ["skybox", "gradient", "black", "white"];
		viewer.setDescription(``);
		viewer.loadSettingsFromURL();

		viewer.loadGUI(() => {
			viewer.setLanguage('en');
			$("#menu_appearance").next().show();
			$("#menu_tools").next().show();
			$("#menu_scene").next().show();
			// viewer.toggleSidebar();
      // viewer.setNavigationMode(EarthControls); // TODO Hack: changed default in viewer.js line 234
      // $('#show_bounding_box').trigger("click");
      $("#splat_quality_options_hq").trigger("click");
      // viewer.scene.view.position.set(300198.109, 4701144.537, 349.871);
      // viewer.scene.view.lookAt(new THREE.Vector3(299900.954, 4701576.919, 66.197));
		});

		// Create Axes Helper:
		const axesHelper = new THREE.AxesHelper(20);
		viewer.scene.scene.add(axesHelper);

		window.animationEngine = new AnimationEngine();

		// TODO Fix these hardcoded values
		let tstart = 1495189467.63;
		let tend = 1495189467.63+600.5599999427795;
		let playbackRate = 1.0;
		animationEngine.configure(tstart, tend, playbackRate);
		animationEngine.launch();

		// Animation Start/Stop Callbacks:
		// TODO Put these somewhere better
		{
			let playbutton = document.getElementById("playbutton");
			let pausebutton = document.getElementById("pausebutton");

			animationEngine.preStartCallback = function () {
				if (!animationEngine.isPlaying) {
					$("#playbutton").trigger("mousedown");

					// Track Camera Transform Information:
					// debugger; // world frame matrix
					if (!window.camControlInitialized) {
						window.camDeltaTransform.camStart = viewer.scene.getActiveCamera().matrixWorld.clone();
						window.camDeltaTransform.vehicleStart = viewer.scene.scene.getObjectByName("vehicle").position.clone();
						window.camControlInitialized = true;
					}
					window.camDeltaTransform.camEnd = viewer.scene.getActiveCamera().matrixWorld.clone();
					window.camDeltaTransform.vehicleEnd = viewer.scene.scene.getObjectByName("vehicle").position.clone();

					window.camPointLocalFrame.position.setFromMatrixPosition(window.camDeltaTransform.camEnd).sub(camDeltaTransform.vehicleEnd);

					let camDirection = viewer.scene.getActiveCamera().getWorldDirection().clone();
					let camPosition = viewer.scene.getActiveCamera().position.clone();
					let target = new THREE.Vector3().addVectors(camPosition, camDirection);
					window.camTargetLocalFrame.position.copy(target.sub(camDeltaTransform.vehicleEnd));
				}
			}

			animationEngine.preStopCallback = function() {
				if (animationEngine.isPlaying) {
					$("#pausebutton").trigger("mousedown");

					// Track Camera Transform Information:
					window.camDeltaTransform.vehicle = viewer.scene.scene.getObjectByName("vehicle").position.clone();
				}
			}

		}

		// List of all Tween Target Update Functions:
		// TODO Organize these (move them to the right place)
		{

			// PointCloud:
			animationEngine.tweenTargets.push((gpsTime) => {
				// debugger; // account for pointcloud offset
				let minGpsTime = gpsTime-0.05;
				let maxGpsTime = gpsTime+0.05;
				viewer.setFilterGPSTimeRange(minGpsTime, maxGpsTime);
				viewer.setFilterGPSTimeExtent(minGpsTime-10, maxGpsTime+10);
			});

			// Playbar:
			animationEngine.tweenTargets.push((gpsTime) => {
				let slider = document.getElementById("myRange");
				let output = document.getElementById("demo");
				let tmin = document.getElementById("playbar_tmin");
				let tmax = document.getElementById("playbar_tmax");
				let toggleplay = document.getElementById("toggleplay");
				// TODO add playbackSpeed
				output.innerHTML = slider.value;

				let t = (gpsTime - animationEngine.tstart) / (animationEngine.timeRange);
				slider.value = 100*t;
				output.innerHTML = (gpsTime - animationEngine.tstart).toFixed(4); // Centered to zero
			});

			// RTK:
			animationEngine.tweenTargets.push((gpsTime) => {
				try{
					let t = (gpsTime - animationEngine.tstart) / (animationEngine.timeRange);
					let bunny = viewer.scene.scene.getObjectByName("vehicle");
					let lastRtkPoint = bunny.position.clone();
					let lastRtkOrientation = bunny.rotation.clone();
					let lastTransform = bunny.matrixWorld.clone();
					// debugger; //bunny
					let rtkPoint = animation.getPoint(t); // TODO rename animation --> just use CatmullRomCurve3 directly
					let vehicleOrientation = bunny.orientationPath.getPoint(t); // TODO same as above, also double check interpolation is legit
					rtkPoint.z -= 2.0; // TODO remove hardcoded value
					bunny.position.copy(rtkPoint);
					applyRotation(bunny, vehicleOrientation.x, vehicleOrientation.y, vehicleOrientation.z);
					bunny.updateMatrixWorld();

					// Apply Camera Transformation:
					let newTransform = bunny.matrixWorld.clone();
					let lastTransformInverse = lastTransform.getInverse(lastTransform);
					let deltaTransform = lastTransformInverse.premultiply(newTransform);
					// let camera = viewer.scene.getActiveCamera();
					viewer.scene.view.position.applyMatrix4(deltaTransform);

					// Set Elevation:
					let elevationDeltaMin = -0;
					let elevationDeltaMax = 2;
					let clouds = viewer.scene.pointclouds;
					for (let ii=0, numClouds = clouds.length; ii<numClouds; ii++) {
							viewer.scene.pointclouds[ii].material.elevationRange = [rtkPoint.z+elevationDeltaMin, rtkPoint.z+elevationDeltaMax];
							// debugger; //pointclouds
					}

				} catch (e) {
					console.error("Caught error: ",e);
				}
			});

			// Camera:
			let updateCamera = false;
			let lag = 1.01; // seconds
			let camPointZOffset = 10; // meters
			window.camControlInitialized = false;
			window.camPointNeedsToBeComputed = true;
			window.camControlInUse = false;
			window.camDeltaTransform = {camStart: new THREE.Matrix4(), vehicleStart: new THREE.Vector3(), camEnd: new THREE.Matrix4(), vehicleEnd: new THREE.Vector3()};
			window.camPointLocalFrame = {position: new THREE.Vector3(-10,0,10)};
			window.camTargetLocalFrame = {position: new THREE.Vector3(0, 0, 0)};

			function pauseAndGetVehiclePosition(event) {
				if (event.shiftKey) {
					animationEngine.stop();
					window.camControlInUse = true;
				}
			}
			function resumeAndGetCameraPosition(event) {
				if (window.camControlInUse) {
					animationEngine.start();
					window.camControlInUse = false;
				}
			}
			viewer.renderArea.addEventListener("mousedown", (e) => {
				// Update Camera Local Frame:
				window.camPointLocalFrame.position = viewer.scene.getActiveCamera().position.clone().sub(viewer.scene.scene.getObjectByName("vehicle").position.clone());

				// Update Target Local Frame:
				let camDirection = viewer.scene.getActiveCamera().getWorldDirection().clone();
				let camPosition = viewer.scene.getActiveCamera().position.clone();
				let target = new THREE.Vector3().addVectors(camPosition, camDirection);
				window.camTargetLocalFrame.position.copy(target.sub(viewer.scene.scene.getObjectByName("vehicle").position.clone()));

			});
			// viewer.renderArea.addEventListener("mouseup", resumeAndGetCameraPosition);
			viewer.renderArea.addEventListener("keypress", (e) => {
				if (e.key == "r") {
					window.camPointLocalFrame.position.set(-10, 0, 10);
					window.camTargetLocalFrame.position.set(0,0,0);
					window.scene.view.lookAt(camTargetLocalFrame.add(viewer.scene.scene.getObjectByName("vehicle").position.clone()));
				}
			});
			animationEngine.tweenTargets.push((gpsTime) => {
				if (updateCamera && !window.camControlInUse) {

					let vehicle = viewer.scene.scene.getObjectByName("vehicle");

					let targetVehicleFrame = window.camTargetLocalFrame.position.clone();
					let targetWorldFrame = targetVehicleFrame.add(vehicle.position.clone());

					let camPointVehicleFrame = window.camPointLocalFrame.position.clone();
					let camPointWorldFrame = camPointVehicleFrame.add(vehicle.position.clone());

					viewer.scene.view.position.copy(camPointWorldFrame);
					// viewer.scene.view.lookAt(targetWorldFrame);
				}
			});

		}


		// TODO Just for testing:
		tweenInitAll();

// TODO FROM HERE
		// Load Lanes Truth Data:
		loadLanes(s3, bucket, name, (laneGeometries) => {

			// TODO TESTING -- REMOVE
			// debugger;
			for (let ii=0, len=laneGeometries.all.length; ii<len; ii++) {
				viewer.scene.scene.add(laneGeometries.all[ii]);
			}
			// return;


			// // TODO merging into single geometry doesn't work yet -- so leave as false
			// let mergeLanesIntoSingleGeometry = false; // NOTE creating a single geometry object is more performant than adding all lanes individually
			// if (mergeLanesIntoSingleGeometry) {
			// 	let allLanesGeometry = new THREE.Geometry();
			// 	for (let ii=0, len=laneGeometries.left.length; ii<len; ii++){
			// 		allLanesGeometry.merge(laneGeometries.left[ii].geometry);
			// 		allLanesGeometry.merge(laneGeometries.spine[ii].geometry);
			// 		allLanesGeometry.merge(laneGeometries.right[ii].geometry);
			// 	}
			// 	allLanesGeometry = new THREE.BufferGeometry().fromGeometry( allLanesGeometry );
			// 	viewer.scene.scene.add(allLanesGeometry);
			//
			// } else {
			// 	for (let ii=0, len=laneGeometries.left.length; ii<len; ii++) {
			// 		viewer.scene.scene.add(laneGeometries.left[ii]);
			// 		viewer.scene.scene.add(laneGeometries.spine[ii]);
			// 		viewer.scene.scene.add(laneGeometries.right[ii]);
			// 	}
			// }
		});
// TODO TILL HERE
//
//
//
// 		// Load Test Box:
// 		{
// 			let position = new THREE.Vector3(300139.728, 4701364.107, 241.147);
// 			let geom = new THREE.BoxBufferGeometry(100, 100, 100);
// 			let materialNormal = new THREE.MeshNormalMaterial();
//
// 			let geo = new THREE.WireframeGeometry( geom );
// 			let timestamps = [];
// 			for (let ii=0; ii<60; ii++){
// 					timestamps.push(0.5);
// 			};
// 			geo.addAttribute('gpsTime', new THREE.Float32BufferAttribute(timestamps, 1));
// 			// var geo = new THREE.EdgesGeometry( geom );
// 			let material = new THREE.LineBasicMaterial( { color: 0xffffff, linewidth: 2 } );
//
// 			// uniforms
// 	    let uniforms = {
// 	          color: { value: new THREE.Color( 0x00ff00 ) },
// 	          minGpsTime: {value: 0.0 },
// 	          maxGpsTime: {value: 0.5 },
// 	          initialTime: {value: 0} // TODO not used
// 	      };
// 			let shaderMaterial = new THREE.ShaderMaterial( {
//
// 		       uniforms:       uniforms,
// 		       vertexShader:   document.getElementById( 'vertexshader' ).textContent,
// 		       fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
// 		       transparent:    true
//
// 		   });
//
//
// 			var wireframe = new THREE.LineSegments( geo, shaderMaterial );
//
// 			wireframe.position.copy(position);
// 			wireframe.name = "testbox";
//
// 			var mesh = new THREE.Mesh(geom, materialNormal);
// 			mesh.position.copy(position);
//
// 			wireframe.onBeforeRender = function(renderer, scene, camera, geometry, material, group) {
// 				let testBox = viewer.scene.scene.getObjectByName("testbox");
// 				let t = animationEngine.timeline.t - animationEngine.tstart;
// 				testBox.material.uniforms.minGpsTime.value = t - 1;
// 				testBox.material.uniforms.maxGpsTime.value = t + 1;
// 			}
//
// 			viewer.scene.scene.add(wireframe);
//
// 		}
//
//
//
//
// // TODO FROM HERE
// 	loadGaps((gapGeometries) => {
//
// 		// TODO TESTING -- REMOVE
// 		// debugger;
// 		for (let ii=0, len=gapGeometries.left.length; ii<len; ii++) {
// 			if (ii < 1000) {
// 				viewer.scene.scene.add(gapGeometries.left[ii]);
// 			}
// 		}
// 	});
// // TODO TILL HERE



// TODO FROM HERE
		// TODO Move this somewhere else
		// uniforms
		let uniforms = {
					color: { value: new THREE.Color( 0x00ff00 ) },
					minGpsTime: {value: 0.0 },
					maxGpsTime: {value: 0.5 },
					initialTime: {value: 0}, // TODO not used
					// offset: {value: new THREE.Vector3(0,0,0)}
			};
		let shaderMaterial = new THREE.ShaderMaterial( {

				 uniforms:       uniforms,
				 vertexShader:   document.getElementById( 'vertexshader' ).textContent,
				 fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
				 transparent:    true

		 });
		let trackShaderMaterial = shaderMaterial.clone();
		loadTracks(s3, bucket, name, trackShaderMaterial, animationEngine, (trackGeometries) => {
			for (let ii=0, len=trackGeometries.bbox.length; ii<len; ii++) {
				viewer.scene.scene.add(trackGeometries.bbox[ii]); // Original
			}
			animationEngine.tweenTargets.push((gpsTime) => {
				let currentTime = gpsTime - animationEngine.tstart;
				trackShaderMaterial.uniforms.minGpsTime.value = currentTime - 0.05;
				trackShaderMaterial.uniforms.maxGpsTime.value = currentTime + 0.05;
			});
		});

		let detectionShaderMaterial = shaderMaterial.clone();
		detectionShaderMaterial.uniforms.color.value = new THREE.Color(0xFFA500);
		loadDetections(s3, bucket, name, detectionShaderMaterial, animationEngine, (detectionGeometries) => {
			debugger; // detectionGeometries;
			for (let ii=0, len=detectionGeometries.bbox.length; ii<len; ii++) {
				viewer.scene.scene.add(detectionGeometries.bbox[ii]); // Original
			}

			animationEngine.tweenTargets.push((gpsTime) => {
				let currentTime = gpsTime - animationEngine.tstart;
				detectionShaderMaterial.uniforms.minGpsTime.value = currentTime - 0.05;
				detectionShaderMaterial.uniforms.maxGpsTime.value = currentTime + 0.05;
			});
		});
// TODO TILL HERE

    // // Load Radar Cubes:
    // loadRadar((geometry, t_init) => {
		//
    //   // uniforms
    //   uniforms = {
    //       color: { value: new THREE.Color( 0xffff00 ) },
    //       minGpsTime: {value: 0.0 },
    //       maxGpsTime: {value: 110.0 },
    //       initialTime: {value: t_init}
    //   };
		//
    //   // point cloud material
    //   var shaderMaterial = new THREE.ShaderMaterial( {
		//
    //       uniforms:       uniforms,
    //       vertexShader:   document.getElementById( 'vertexshader' ).textContent,
    //       fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
    //       transparent:    true
		//
    //   });
		//
    //   var material = new THREE.PointsMaterial( {size:1.0} );
    //   var mesh = new THREE.Points(geometry, shaderMaterial);
    //   mesh.name = "radar";
    //   // debugger; //radar tracks added?
    //   viewer.scene.scene.add(mesh);
    // });

// TODO FROM HERE
		// Load Radar:
		loadRadar(s3, bucket, name, (geometry,t_init, boxBufferGeometries) => {

			let boxMesh = new THREE.Mesh(boxBufferGeometries, new THREE.MeshBasicMaterial({color: 0xffff00}) );
			boxMesh.name = "radar_boxes";
			// viewer.scene.scene.add(boxMesh);


			// uniforms
			uniforms = {
					color: { value: new THREE.Color( 0xffff00 ) },
					minGpsTime: {value: 0.0 },
					maxGpsTime: {value: 110.0 },
					initialTime: {value: t_init}
			};

			// point cloud material
			var shaderMaterial = new THREE.ShaderMaterial( {

					uniforms:       uniforms,
					vertexShader:   document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
					transparent:    true

			});

			var material = new THREE.PointsMaterial( {size:1.0} );
			var mesh = new THREE.Points(geometry, shaderMaterial);
			mesh.name = "radar";
			// debugger; //radar tracks added?
			viewer.scene.scene.add(mesh);

			// Create tween:
			{
				animationEngine.tweenTargets.push( (t) => {
					// debugger;
					let minGpsTime = t - .05;
					let maxGpsTime = t + .05;
					let radarOffset = t_init;
					let minRadarTime = minGpsTime - radarOffset;
					let maxRadarTime = maxGpsTime - radarOffset;
					let radar = viewer.scene.scene.getObjectByName("radar")
					radar.material.uniforms.minGpsTime.value = minRadarTime;
					radar.material.uniforms.maxGpsTime.value = maxRadarTime;
				});
			}
		});
// TODO TILL HERE

    // // Load Radar:
    // loadRadar(s3, bucket, name, (geometry, t_init) => {
		//
    //   // uniforms
    //   uniforms = {
    //       color: { value: new THREE.Color( 0xffff00 ) },
    //       minGpsTime: {value: 0.0 },
    //       maxGpsTime: {value: 110.0 },
    //       initialTime: {value: t_init}
    //   };
		//
    //   // point cloud material
    //   var shaderMaterial = new THREE.ShaderMaterial( {
		//
    //       uniforms:       uniforms,
    //       vertexShader:   document.getElementById( 'vertexshader' ).textContent,
    //       fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
    //       transparent:    true
		//
    //   });
		//
    //   const material = new THREE.PointsMaterial( {size:1.0} );
    //   const mesh = new THREE.Points(geometry, shaderMaterial);
    //   mesh.name = "radar";
    //   // debugger; //radar tracks added?
    //   viewer.scene.scene.add(mesh);
    // });

    // Load RTK:
      loadRtk(s3, bucket, name, (pos, rot, t_init) => {
      const path = pos.map(v => new THREE.Vector3(...v));
      const orientations = rot.map(v => new THREE.Vector3(...v));

      const animationPath = new Potree.AnimationPath(path);
      animationPath.closed = false;
	  	const orientationPath = new THREE.CatmullRomCurve3(orientations, animationPath.closed); // NOTE: orientations are represented as a parametric curve in 3d space, this breaks at pi to negative pi transition

      { // render the path
        let geometry = animationPath.getGeometry();
        let material = new THREE.LineBasicMaterial();
        material.uniforms = {initialTime:{value:t_init}};
				material.opacity = 0.0;
				material.transparent = true;
        let line = new THREE.Line(geometry, material, {closed: animationPath.closed});
        line.name = "rtk";
        viewer.scene.scene.add(line);
        console.log("Rendered Path");
      }


      // CREATE VEHICLE OBJECT:
      // NOTE for Mustang: {texture: models/bodybkgd.JPG, mesh: models/1967-shelby-ford-mustang.obj}
      // NOTE for Volt: {texture: models/Chevy_Volt_Segmented/Chevrolet_Volt_v1_exterior.png, mesh: resources/models/Chevy_Volt_Segmented/Chevy_Volt_2016.obj}
      let manager = new THREE.LoadingManager();
      manager.onProgress = function ( item, loaded, total ) {
        console.log( item, loaded, total );
      };
      let textureLoader = new THREE.TextureLoader( manager );
      let texture = textureLoader.load(`${Potree.resourcePath}/models/Chevy_Volt_Segmented/reflection_1.png`);
      // let texture = textureLoader.load(`${Potree.resourcePath}/models/bodybkgd.JPG`);
      let onProgress = function ( xhr ) {
        if ( xhr.lengthComputable ) {
          let percentComplete = xhr.loaded / xhr.total * 100;
          console.log( Math.round(percentComplete, 2) + '% downloaded' );
        }
      };
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;

      let geometry = new THREE.SphereGeometry( 2, 32, 32 );
      let material = new THREE.MeshNormalMaterial( {side: THREE.DoubleSide, opacity: 0.92,transparent:true});
      let sphere = new THREE.Mesh( geometry, material );
      sphere.position.copy(new THREE.Vector3(...pos[0]));
      console.log(sphere);

      // viewer.scene.scene.add( sphere );
      console.log("Sphere added");


      { // Load Textured bunny from obj
        let onError = function ( xhr ) {};
        let loader = new THREE.OBJLoader( manager );
        loader.load(`${Potree.resourcePath}/models/Chevy_Volt_Segmented/Chevy_Volt_2016.obj`,
                    function ( object ) {
          object.traverse( function ( child ) {
            if ( child instanceof THREE.Mesh ) {
              child.material.map = texture;
            }
          } );


					// Add Polar Grid Helper:
					const gridHelper = new THREE.GridHelper( 1000, 10, 0x0000ff, 0x808080 );
					gridHelper.name = "Grid";
					gridHelper.rotateOnAxis(new THREE.Vector3(1,0,0), Math.PI/2);
					const polarGridHelper = new THREE.PolarGridHelper( 500, 16, 10, 64, 0x0000ff, 0x808080 );
					polarGridHelper.name = "PolarGrid";
					polarGridHelper.rotateOnAxis(new THREE.Vector3(1,0,0), Math.PI/2);
					const axesHelper = new THREE.AxesHelper(1000);
					axesHelper.name = "Axes";
					axesHelper.rotateOnAxis(new THREE.Vector3(0,0,1), -Math.PI/2);


					object.add( gridHelper );
					object.add( polarGridHelper );
					object.add( axesHelper );

          object.name = "vehicle";
          object.position.set(...pos[0]);
          object.scale.multiplyScalar(.01);
					object.orientationPath = orientationPath;
          object.rotation.set(0*Math.PI / 2, 0*Math.PI/2., 1*Math.PI/2.0); // Chevy Volt
					object.initialRotation = object.rotation.clone(); // NOTE is this used?

					// TODO New Camera Initialization:
					let box = new THREE.Box3().setFromObject(object);
					let node = new THREE.Object3D();
					node.boundingBox = box;
					viewer.zoomTo(node, 1, 500);
					viewer.scene.view.lookAt(object.position);


          viewer.scene.scene.add( object );

					removeLoadingScreen();

        }, onProgress, onError );
      }

      // // Create sprite:
      // let hudTexture = textureLoader.load(`${Potree.resourcePath}/images/4076.jpg`);
      // var spriteMaterial = new THREE.SpriteMaterial({map:hudTexture});
      // var sprite = new THREE.Sprite(spriteMaterial);
      // sprite.position.set(...pos[0]);
      // sprite.position.add(new THREE.Vector3(10,10,10));
      // sprite.scale.set(5,5,1);
      // sprite.name = "sprite";
      // viewer.scene.scene.add(sprite);






      // ANIMATION:
      { // create Animation Path & make light follow it


        {// ANIMATION + SLIDER LOGIC:
          let slider = document.getElementById("myRange");
          let output = document.getElementById("demo");
					let tmin = document.getElementById("playbar_tmin");
					let tmax = document.getElementById("playbar_tmax");
      // let toggleplay = document.getElementById("toggleplay");
          output.innerHTML = slider.value;

          // Animate from beginning to end
          let start = 0;
          let end = Infinity;
          let speed = 33;	// empirically set as "close to realtime"
          let animation = animationPath.animate(start, end, speed, animate);

					function animate() {
						// DO NOTHING -- Placeholder will be removed
					}

					// function animate(t, updateCamera=true) {
					// 	debugger;
          //   animation.repeat = true;
					//
					//
					// 	// TODO cache this to improve speed?
          //   lidarOffset = 1495189467.550001;  // TODO Hardcoded b/c PotreeConverter is throwing away initial offset
          //   rtkOffset = viewer.scene.scene.getObjectByName("rtk").material.uniforms.initialTime.value;
          //   radarOffset = viewer.scene.scene.getObjectByName("radar").material.uniforms.initialTime.value;
          //   timeMin = Math.min(lidarOffset, rtkOffset, radarOffset);
          //   lidarRange = viewer.scene.pointclouds[0].pcoGeometry.nodes.r.gpsTime.range;
          //   radarRange = 583.649169921875;  // TODO Hardcoded
          //   rtkRange = 600.5599999427795;   // TODO Hardcoded
          //   timeMax = Math.max((lidarRange+lidarOffset), (radarRange+radarOffset), (rtkRange+rtkOffset));
          //   timeOffset = timeMin;
          //   timeRange = timeMax - timeMin;
					//
          //   // console.log("Radar Initial Time: ", radarOffset);
          //   // console.log("RTK Initial Time: ", rtkOffset);
          //   // debugger;
					//
					//
          //   // t is a value between 0 and 1 in rtkTime frame
          //   var gpsTime = (rtkRange*t) + rtkOffset;  // Convert from rtkTime to gpsTime
					//
          //   // TODO define slider time frame
          //   slider.value = 100*t; // NOTE this is currently only using the rtkTime as the time frame
          //   output.innerHTML = (gpsTime-rtkOffset).toFixed(4); // Centered to zero
					//
          //   // use getPoint(t) to map from t to the position on the animation path
					// 	var bunny = viewer.scene.scene.getObjectByName("bunny");
          //   let rtkPoint = animation.getPoint(t); // NOTE t is in rtkTime
					// 	let vehicleOrientation = bunny.orientationPath.getPoint(t);
          //   rtkPoint.z -= 2.0;
          //   sphere.position.copy(rtkPoint);
          //   bunny.position.copy(rtkPoint);
					// 	applyRotation(bunny, vehicleOrientation.x, vehicleOrientation.y, vehicleOrientation.z);
					// 	bunny.visible = true;
          //   // sprite.position.copy(point.add(new THREE.Vector3(10,10,10)));
					//
					//
          //   // Set Time in Material:
          //   viewer.scene.pointclouds[0].material.uniforms.timeVal.value = t; // TODO not used I think
          //   // debugger; //update radar material here
					//
          //   // Create GPS Time Clipping Event:
					//
          //   var minGpsTime = gpsTime + parseFloat(tmin.value);
          //   var maxGpsTime = gpsTime + parseFloat(tmax.value);
					//
					// 	// debugger; // maxGpsTime
          //   // Animate Point Cloud:
          //   minLidarTime = minGpsTime - lidarOffset;
          //   maxLidarTime = maxGpsTime - lidarOffset;
          //   viewer.setFilterGPSTimeRange(minLidarTime, maxLidarTime);
          //   viewer.setFilterGPSTimeExtent(minGpsTime-10, maxGpsTime+10);
					//
          //   // Animate Radar:
					// 	// TODO HERE
          //   // minRadarTime = minGpsTime - radarOffset;
          //   // maxRadarTime = maxGpsTime - radarOffset;
          //   // var radar = viewer.scene.scene.getObjectByName("radar")
          //   // radar.material.uniforms.minGpsTime.value = minRadarTime;
          //   // radar.material.uniforms.maxGpsTime.value = maxRadarTime;
          //   // console.log(radar);
					//
          //   // debugger; // check the rtkTime, slider time, radar time, lidar time
					//
					// 	if (updateCamera) {
					// 		let camera = viewer.scene.getActiveCamera();
					// 		let lag = 1.01; // seconds
					// 		lagTime = Math.max(0, (gpsTime - lag - rtkOffset)/rtkRange);
					//
					// 		// let lagTime = Math.max(0, (gpsTime-lag)/viewer.scene.pointclouds[0].pcoGeometry.nodes.r.gpsTime.range);
					// 		let camPoint = animation.getPoint(lagTime);  // Get point with 2 second lag
					// 		camPoint.z += 10;
					// 		viewer.scene.view.position.copy(camPoint); // changed from camera
					// 		var targetPosition = new THREE.Vector3(sphere.position.x, sphere.position.y, sphere.position.z+2);
					// 		viewer.scene.view.lookAt(targetPosition);
					// 	}
          // }
          window.animation = animation;


          // Playbar Button Functions:
          let playbutton = document.getElementById("playbutton");
          let pausebutton = document.getElementById("pausebutton");
          pausebutton.addEventListener("mousedown", () => {
						tween.stop();
						animationEngine.stop();
          });
          playbutton.addEventListener("mousedown", () => {
						tween.start();
						animationEngine.start();
          });

					slider.addEventListener("input", () => {
						animationEngine.stop();
						var val = slider.value/100.0;
						animationEngine.timeline.t = val*animationEngine.timeRange + animationEngine.tstart;
						animationEngine.updateTimeForAll();
					});

					slider.addEventListener("wheel", () => {
						animationEngine.stop();
						var val = slider.value/100.0;
						animationEngine.timeline.t = val*animationEngine.timeRange + animationEngine.tstart;
						animationEngine.updateTimeForAll();
					});

					window.addEventListener("keypress", (e) => {
						if (e.charCode == 32) {
			          if (toggleplay.checked) {
			            animationEngine.start();
			          } else {
			            animationEngine.stop();
			          }
			        }
						});
        }

        window.animationPath = animationPath;
				window.animation.pause();
      }

    });

			if (runForLocalDevelopment) {
				Potree.loadPointCloud("../pointclouds/external/full-cloud/cloud.js", "full-cloud", e => {
					const pointcloud = e.pointcloud;
		      const material = pointcloud.material;
		      console.log(pointcloud.pcoGeometry.nodes.r.gpsTime);
		      viewer.scene.addPointCloud(pointcloud);
		      material.pointColorType = Potree.PointColorType.HEIGHT; // any Potree.PointColorType.XXXX
					material.gradient = Potree.Gradients.GRAYSCALE; // Can define custom gradient or look up in Potree.Gradients
		      material.size = 0.09;
		      material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
		      material.shape = Potree.PointShape.SQUARE;

		      viewer.scene.view.position.set(300198.109, 4701144.537, 349.871);
		      viewer.scene.view.lookAt(new THREE.Vector3(299900.954, 4701576.919, 66.197));
				});
			} else if (name === 'Data/basemap-demo') {
        Potree.loadPointCloud({s3, bucket, name}, "basemap", e => {
		      const pointcloud = e.pointcloud;
		      const material = pointcloud.material;
		      console.log(pointcloud.pcoGeometry.nodes.r.gpsTime);
		      viewer.scene.addPointCloud(pointcloud);
		      material.pointColorType = Potree.PointColorType.COLOR; // any Potree.PointColorType.XXXX
		      material.color = new THREE.Color().setRGB(0.99, 0.99, 0.99);
		      material.size = 0.09;
		      material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
		      material.shape = Potree.PointShape.SQUARE;

		      viewer.scene.view.position.set(300198.109, 4701144.537, 349.871);
		      viewer.scene.view.lookAt(new THREE.Vector3(299900.954, 4701576.919, 66.197));
		      // viewer.toggleNavigationCube();
		      $("#playbutton").click();
		    });
      } else if (name === 'Data/fullcloud-demo') {
        Potree.loadPointCloud({s3, bucket, name}, "fullcloud", e => {
		      const pointcloud = e.pointcloud;
		      const material = pointcloud.material;
		      console.log(pointcloud.pcoGeometry.nodes.r.gpsTime);
		      viewer.scene.addPointCloud(pointcloud);
		      material.pointColorType = Potree.PointColorType.HEIGHT; // any Potree.PointColorType.XXXX
		      material.size = 0.09;
		      material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
		      material.shape = Potree.PointShape.SQUARE;

		      viewer.scene.view.position.set(300198.109, 4701144.537, 349.871);
		      viewer.scene.view.lookAt(new THREE.Vector3(299900.954, 4701576.919, 66.197));
		      // viewer.toggleNavigationCube();
		      $("#playbutton").click();
		    });
        Potree.loadPointCloud({s3, bucket, name: 'Data/basemap-demo'}, "basemap", e => {
		      const pointcloud = e.pointcloud;
		      const material = pointcloud.material;
		      console.log(pointcloud.pcoGeometry.nodes.r.gpsTime);
		      viewer.scene.addPointCloud(pointcloud);
		      material.pointColorType = Potree.PointColorType.COLOR; // any Potree.PointColorType.XXXX
		      material.color = new THREE.Color().setRGB(0.99, 0.99, 0.99);
		      material.size = 0.09;
		      material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
		      material.shape = Potree.PointShape.SQUARE;
		    });
      } else {
        Potree.loadPointCloud({s3, bucket, name}, name.substring(5), e => {
		      const pointcloud = e.pointcloud;
		      const material = pointcloud.material;
		      console.log(pointcloud.pcoGeometry.nodes.r.gpsTime);
		      viewer.scene.addPointCloud(pointcloud);
		      material.pointColorType = Potree.PointColorType.HEIGHT; // any Potree.PointColorType.XXXX
					material.gradient = Potree.Gradients.YELLOW_GREEN;
		      material.size = 0.09;
		      material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
		      material.shape = Potree.PointShape.SQUARE;

		      // viewer.scene.view.position.set(300198.109, 4701144.537, 349.871);
		      // viewer.scene.view.lookAt(new THREE.Vector3(299900.954, 4701576.919, 66.197));
		      // viewer.toggleNavigationCube();
		      $("#playbutton").click();
		    });
      }

		</script>


  </body>
</html>
