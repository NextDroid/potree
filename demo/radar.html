<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta name="description" content="">
	<meta name="author" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
	<title>Potree Viewer</title>

	<link rel="stylesheet" type="text/css" href="../build/potree/potree.css">
	<link rel="stylesheet" type="text/css" href="../libs/jquery-ui/jquery-ui.min.css">
	<link rel="stylesheet" type="text/css" href="../libs/perfect-scrollbar/css/perfect-scrollbar.css">
	<link rel="stylesheet" type="text/css" href="../libs/openlayers3/ol.css">
	<link rel="stylesheet" type="text/css" href="../libs/spectrum/spectrum.css">
	<link rel="stylesheet" type="text/css" href="../libs/jstree/themes/mixed/style.css">
	<link rel="stylesheet" href="../common/overlay.css" type="text/css">
	<link rel="stylesheet" href="../common/calibration-panels.css" type="text/css">
	<link rel="stylesheet" href="../common/loading-bar.css" type="text/css">
  <!-- <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet"> -->
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
	<script src="../node_modules/flatbuffers/js/flatbuffers.js"></script>
	<!-- <script type="module" src="../readers/polyline3D.js"></script>
	<script type="module" src="../schemas/GroundTruth_generated_tmp.js"></script> -->
  <script type="module" src="radarLoader.js"></script>
  <script type="module" src="rtkLoader.js"></script>
  <script type="module" src="rtkLoaderFlatbuffer.js"></script>
  <script type="module" src="laneLoader.js"></script>
  <script type="module" src="trackLoader.js"></script>
  <script type="module" src="gapsLoader.js"></script>
	<script type="module" src="remLoader.js"></script>
	<script type="module" src="calibrationManager.js"></script>
  <link rel="stylesheet" type="text/css" href="../common/playbar.css">
</head>

<body>
	<script src="../libs/jquery/jquery-3.1.1.min.js"></script>
	<script src="../libs/spectrum/spectrum.js"></script>
	<script src="../libs/perfect-scrollbar/js/perfect-scrollbar.jquery.js"></script>
	<script src="../libs/jquery-ui/jquery-ui.min.js"></script>
	<script src="../libs/three.js/build/three.min.js"></script>
	<script src="../libs/other/BinaryHeap.js"></script>
	<script src="../libs/tween/tween.min.js"></script>
	<script src="../libs/d3/d3.js"></script>
	<script src="../libs/proj4/proj4.js"></script>
	<script src="../libs/openlayers3/ol.js"></script>
	<script src="../libs/i18next/i18next.js"></script>
	<script src="../libs/jstree/jstree.js"></script>
	<script src="../build/potree/potree.js"></script>
	<script src="../libs/plasio/js/laslaz.js"></script>
  <script src="../libs/other/OBJLoader.js"></script>
	<script type="module" src="../common/playbar.js"></script>
	<script src="../common/loading-bar.js"></script>
	<script type="module" src="../common/overlay.js"></script>
	<script src="../common/calibration-panels.js"></script>
	<script src="../node_modules/three.meshline/src/THREE.MeshLine.js"></script>
	<script type="module" src="animationEngine.js"></script>
	<script type="module" src="RtkTrajectory.js"></script>
	<script type="module" src="../src/loader/PointAttributes.js"></script>
	<script type='module' src="paramLoader.js"></script>
	<script type='module' src="loaderHelper.js"></script>

	<!-- TODO REMOVE BELOW -->
	<script src="tweenTest.js"></script>



	<!-- <script src="../common/playbar.css"></script> -->


	<!-- INCLUDE ADDITIONAL DEPENDENCIES HERE -->
  <script src="https://sdk.amazonaws.com/js/aws-sdk-2.339.0.min.js"></script>

	<!-- INCLUDE SETTINGS HERE -->

	<div class="potree_container" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px; ">
	  <div id="potree_render_area"></div>
		<div id="potree_sidebar_container"></div>
	</div>


  <script type="x-shader/x-vertex" id="vertexshader">

      attribute float alpha;
      attribute float gpsTime;

      uniform float minGpsTime;
      uniform float maxGpsTime;

	  uniform vec3 offset;

      varying float vAlpha;

      void main() {

        if (minGpsTime <= gpsTime && gpsTime <= maxGpsTime) {
          vAlpha = 1.0;
        } else {
          vAlpha = 0.0;
        }


        // if (gpsTime > 30.0) {
				// 	vAlpha = 0.0;
        // } else {
        //   vAlpha = 1.0;
        // }

					// vec4 offset = vec4( 0.0, 0.0, 0.0, 0.0);
					// vec4 offset = vec4( 300016.625, 4701260, 247.1885223388672, 0.0);

          vec4 mvPosition = modelViewMatrix * vec4( position+offset.xyz, 1.0 );
					gl_Position = projectionMatrix * mvPosition;

          gl_PointSize = 8.0;


      }

  </script>

  <script type="x-shader/x-fragment" id="fragmentshader">

      uniform vec3 color;

      varying float vAlpha;

      void main() {

          gl_FragColor = vec4( color, vAlpha );

      }

  </script>




	<script type="module">
		"use strict";
		import { loadLanes } from "../demo/laneLoader.js";
		import { loadTracks } from "../demo/trackLoader.js";
		import { loadDetections } from "../demo/detectionLoader.js";
		import { loadRadar } from "../demo/radarLoader.js";
		import { loadGaps } from "../demo/gapsLoader.js";
		import { loadRem } from "../demo/remLoader.js";
		import { loadVelo2Rtk, loadRtk2Vehicle, storeCalibration } from "../demo/calibrationManager.js";
		import { updateSidebar, togglePointClass } from "../common/custom-sidebar.js";
		import { getLoadingBar } from "../common/overlay.js";
		// import {  } from "../common/overlay.js";
		import { setLoadingScreen, removeLoadingScreen } from "../common/overlay.js";
		import { PointAttributeNames } from "../src/loader/PointAttributes.js";

		// TODO: remove imports that are not needed from param loader
		import { runForLocalDevelopment, params, bucket, region, names, name, visualizationMode,
			annotateLanesAvailable, downloadLanesAvailable, calibrationModeAvailable, accessKeyId,
			secretAccessKey, sessionToken, fonts, theme, comparisonDatasets, s3, getShaderMaterial} from "../demo/paramLoader.js"
		import { loadPotree } from "../demo/loaderHelper.js"

		// setLoadingScreen();

		//TODO: eventually make this function occur upon window being ready
		loadPotree();

// Load Gaps Code (Start)
window.gapsLoaded = false;
$(document).ready(() => {
	// Configure Playbar
	$("#load_gaps_button")[0].style.display="block"
	let loadGapsButton = $("#load_gaps_button")[0];
	loadGapsButton.addEventListener("mousedown", () => {

		if (!window.gapsLoaded) {
			$("#loading-bar")[0].style.display = "none";
			setLoadingScreen();

			let shaderMaterial = getShaderMaterial();
			let gapShaderMaterial = shaderMaterial.clone();
			gapShaderMaterial.uniforms.color.value = new THREE.Color(0x0000ff);
			gapShaderMaterial.depthWrite = false;
			loadGaps(s3, bucket, name, gapShaderMaterial, animationEngine, (gapGeometries) => {
				let gapsLayer = new THREE.Group();
				gapsLayer.name = "Vehicle Gaps";
				for (let ii=0, len=gapGeometries.left.length; ii<len; ii++) {
					// if (ii < 1000) {
						gapsLayer.add(gapGeometries.left[ii]);
					// }
				}
				viewer.scene.scene.add(gapsLayer);
				viewer.scene.dispatchEvent({
					"type": "assessments_layer_added",
					"assessmentsLayer": gapsLayer
				});
				animationEngine.tweenTargets.push((gpsTime) => {
					let currentTime = gpsTime - animationEngine.tstart;
					gapShaderMaterial.uniforms.minGpsTime.value = currentTime - animationEngine.activeWindow.backward;
					gapShaderMaterial.uniforms.maxGpsTime.value = currentTime + animationEngine.activeWindow.forward;
				});
				window.gapsLoaded = true;
				loadGapsButton.disabled = true;
				removeLoadingScreen();
			});
		}
	});
});
// Load Gaps Code (end)




window.detectionsLoaded = false;
$(document).ready(() => {
	// Configure Playbar
	$("#load_detections_button")[0].style.display = "block"
	let loadDetectionsButton = $("#load_detections_button")[0];
	loadDetectionsButton.addEventListener("mousedown", () => {
		if (!window.detectionsLoaded) {
			$("#loading-bar")[0].style.display = "none";
			setLoadingScreen();
			let shaderMaterial = getShaderMaterial();
			let detectionShaderMaterial = shaderMaterial.clone();
			detectionShaderMaterial.uniforms.color.value = new THREE.Color(0xFFA500);
			loadDetections(s3, bucket, name, detectionShaderMaterial, animationEngine, (detectionGeometries) => {
				let detectionLayer = new THREE.Group();
				detectionLayer.name = "Object Detections";
				for (let ii = 0, len = detectionGeometries.bbox.length; ii < len; ii++) {
					detectionLayer.add(detectionGeometries.bbox[ii]);
				}
				viewer.scene.scene.add(detectionLayer);
				viewer.scene.dispatchEvent({
					"type": "truth_layer_added",
					"truthLayer": detectionLayer
				});
				animationEngine.tweenTargets.push((gpsTime) => {
					let currentTime = gpsTime - animationEngine.tstart;
					detectionShaderMaterial.uniforms.minGpsTime.value = currentTime - animationEngine.activeWindow.backward;
					detectionShaderMaterial.uniforms.maxGpsTime.value = currentTime + animationEngine.activeWindow.forward;
				});
				window.detectionsLoaded = true;
				loadDetectionsButton.disabled = true;
				removeLoadingScreen();
			});
		}
	});
});

// Load Tracks Code (End)

    // // Load Radar Cubes:
    // loadRadar((geometry, t_init) => {
		//
    //   // uniforms
    //   uniforms = {
    //       color: { value: new THREE.Color( 0xffff00 ) },
    //       minGpsTime: {value: 0.0 },
    //       maxGpsTime: {value: 110.0 },
    //       initialTime: {value: t_init}
    //   };
		//
    //   // point cloud material
    //   var shaderMaterial = new THREE.ShaderMaterial( {
		//
    //       uniforms:       uniforms,
    //       vertexShader:   document.getElementById( 'vertexshader' ).textContent,
    //       fragmentShader: document.getElementById( 'fragmentshader' ).textContent,
    //       transparent:    true
		//
    //   });
		//
    //   var material = new THREE.PointsMaterial( {size:1.0} );
    //   var mesh = new THREE.Points(geometry, shaderMaterial);
    //   mesh.name = "radar";
    //   // debugger; //radar tracks added?
    //   viewer.scene.scene.add(mesh);
    // });

// Load Radar Code (Start)
		window.radarLoaded = false;
		$(document).ready(() => {
			// Configure Playbar
			$("#load_radar_button")[0].style.display="block"
			let loadRadarButton = $("#load_radar_button")[0];
			loadRadarButton.addEventListener("mousedown", () => {
				if (!window.radarLoaded) {
					$("#loading-bar")[0].style.display = "none";
					setLoadingScreen();

					loadRadar(s3, bucket, name, (geometry,t_init, boxBufferGeometries) => {

						let boxMesh = new THREE.Mesh(boxBufferGeometries, new THREE.MeshBasicMaterial({color: 0xffff00}) );
						boxMesh.name = "radar_boxes";
						// viewer.scene.scene.add(boxMesh);


						// uniforms
						let uniforms = {
								color: { value: new THREE.Color( 0xffff00 ) },
								minGpsTime: {value: 0.0 },
								maxGpsTime: {value: 110.0 },
								initialTime: {value: t_init}
						};

						// point cloud material
						let shaderMaterial = getShaderMaterial()
						var material = new THREE.PointsMaterial( {size:1.0} );
						var mesh = new THREE.Points(geometry, shaderMaterial);
						mesh.name = "radar";
						// debugger; //radar tracks added?
						viewer.scene.scene.add(mesh);
						viewer.scene.dispatchEvent({"type": "sensor_layer_added", "sensorLayer": mesh });


						// Create tween:
						{
							animationEngine.tweenTargets.push( (t) => {
								// debugger;
								let minGpsTime = t - animationEngine.activeWindow.backward;
								let maxGpsTime = t + animationEngine.activeWindow.forward;
								let radarOffset = t_init;
								let minRadarTime = minGpsTime - radarOffset;
								let maxRadarTime = maxGpsTime - radarOffset;
								let radar = viewer.scene.scene.getObjectByName("radar")
								radar.material.uniforms.minGpsTime.value = minRadarTime;
								radar.material.uniforms.maxGpsTime.value = maxRadarTime;
							});
						}
						window.radarLoaded = true;
						loadRadarButton.disabled = true;
						removeLoadingScreen();
					});
				}
			});
		});

		// Listener to store pointcloud material as calibration extrinsics get updated
		window.addEventListener("update-calibration-panel", (e) => {
			console.log("calibration panel updated: ", e.detail);
			const id = e.detail.id;
			const dim = e.detail.dim;
			const val = e.detail.value;

			for (const cloud of viewer.scene.pointclouds) {
				let material = cloud.material;

				if (id == "rtk2vehicle") {
					let rtk2Vehicle = getRtk2Vehicle();
					let vehicleMesh = viewer.scene.scene.getObjectByName("Vehicle").getObjectByName("Vehicle Mesh");

					// Apply Transformations to Vehicle:
					let translation = new THREE.Vector3(rtk2Vehicle.x, rtk2Vehicle.y, rtk2Vehicle.z);
					vehicleMesh.position.copy(translation);
					vehicleMesh.rotation.set(rtk2Vehicle.roll, rtk2Vehicle.pitch, rtk2Vehicle.yaw);

					// Store updated values in mesh:
					material.uniforms.rtk2VehicleXYZNew = {type: "v3", value: new THREE.Vector3(rtk2Vehicle.x, rtk2Vehicle.y, rtk2Vehicle.z)};
					material.uniforms.rtk2VehicleRPYNew = {type: "v3", value: new THREE.Vector3(rtk2Vehicle.roll, rtk2Vehicle.pitch, rtk2Vehicle.yaw)};

				} else if (id == "velo2rtk") {

					let velo2Rtk = getVelo2Rtk();
					material.uniforms.velo2RtkXYZNew = {type: "v3", value: new THREE.Vector3(velo2Rtk.x, velo2Rtk.y, velo2Rtk.z)};
					material.uniforms.velo2RtkRPYNew = {type: "v3", value: new THREE.Vector3(velo2Rtk.roll, velo2Rtk.pitch, velo2Rtk.yaw)};

				} else {
					console.error("Unknown Calibration Extrinsics Id:", id);
				}
			}
		});

		window.canEnableCalibrationPanels = true;
		function canUseCalibrationPanels(attributes) {
			let hasRtkPose = false;
      		let hasRtkOrient = false;
      		for (let attr of attributes) {
      			hasRtkPose = hasRtkPose || (attr.name === PointAttributeNames.RTK_POSE);
      			hasRtkOrient = hasRtkOrient || (attr.name === PointAttributeNames.RTK_ORIENT);
      		}
      		return hasRtkPose && hasRtkOrient
		}

		// Load Pointclouds
		if (runForLocalDevelopment) {
			Potree.loadPointCloud("../pointclouds/test/cloud.js", "full-cloud", e => {
				const pointcloud = e.pointcloud;
				const material = pointcloud.material;
	      		viewer.scene.addPointCloud(pointcloud);
	      		material.pointColorType = Potree.PointColorType.INTENSITY; // any Potree.PointColorType.XXXX
				material.gradient = Potree.Gradients.GRAYSCALE; // Can define custom gradient or look up in Potree.Gradients
	      		material.size = 0.09;
	      		material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
	      		material.shape = Potree.PointShape.SQUARE;

	      		let cloudCanUseCalibrationPanels = canUseCalibrationPanels(pointcloud.pcoGeometry.pointAttributes.attributes);
	      		window.canEnableCalibrationPanels = window.canEnableCalibrationPanels && cloudCanUseCalibrationPanels;

	      		if (window.canEnableCalibrationPanels) {
	      			$(document).ready(() => enablePanels() );

	      		} else {
	      			$(document).ready(() => {
	      				let reason = "Pointcloud was not serialized with the necessary point attributes"
	      				disablePanels(reason);
	      				console.error("Cannot use calibration panels: ", reason);
	      			});
	      		}
			});

	    } else {
        	Potree.loadPointCloud({s3, bucket, name}, name.substring(5), e => {
		    	const pointcloud = e.pointcloud;
			    const material = pointcloud.material;
			    viewer.scene.addPointCloud(pointcloud);
			    material.pointColorType = Potree.PointColorType.INTENSITY; // any Potree.PointColorType.XXXX
				material.gradient = Potree.Gradients.GRAYSCALE;
			    material.size = 0.09;
			    material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
			    material.shape = Potree.PointShape.SQUARE;

	      		let cloudCanUseCalibrationPanels = canUseCalibrationPanels(pointcloud.pcoGeometry.pointAttributes.attributes);
	      		window.canEnableCalibrationPanels = window.canEnableCalibrationPanels && cloudCanUseCalibrationPanels;

	      		if (window.canEnableCalibrationPanels) {
	      			$(document).ready(() => enablePanels() );

	      		} else {
	      			$(document).ready(() => {
	      				disablePanels("Pointcloud was not serialized with the necessary point attributes");
	      				console.error("Cannot use calibration panels");
	      			});
	      		}

	      		$("#playbutton").click();
		    });
      }
		</script>
  </body>
</html>
